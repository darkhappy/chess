title Second selection of a piece 

actor user

'---------GridClick---------'
user -> FormMatch ++ : Grid_Click(object sender, system.EventArgs e)

'Get the clicked position
FormMatch -> Position ++: new Position(int x, int y)
return Position 

'Get board
FormMatch -> GameController ++: GetBoard()
GameController -> Match ++: ExportBoard()
Match -> Board ++: ToString()
loop Add all cell into the board string
    Board -> Cell ++: ToString()
    Cell -> Piece ++: ToString()
    return char
    return "board into string"
end
return "board into string"
return "board into string"
return "board into string"

'--------- Selection ---------'
FormMatch -> GameController ++ : Selection(Position cell)

'Check if the position is out of bounds
GameController -> Position ++: OutOfBounds()
return false

'Check if selection is valid
GameController -> Match ++: ValidSelection(Position cell, bool firstClick)
Match -> Board ++: SameColour(Position cell, Colour colour)
Board -> Board ++: ConvertToIndex()
return index of piece
Board -> Cell ++: Colour
return Black
return false
return true

'---------------------------- Turn -----------------------------'
GameController -> GameController ++: Turn(Position target)
GameController -> Match ++: ValidTurn(Position origin, Position target)

'--------- Valid move ---------'
'Check if origin is not attacking white
Match -> Board ++: ValidMove(Position origin, Position target)
group Check if origin is not attacking the same colour 
    Board -> Board ++: ConvertToIndex(Position position)
    return (int)index of origin 
    Board -> Cell ++: IsEmpty()
    return false
    Board -> Cell ++: Color
    return White
    Board -> Board ++: ConvertToIndex(Position position)
    return (int)index of target 
    Board -> Cell ++: Color
    return Black
end

'Get all possible target of a piece
Board -> Cell ++: ValidMove(Position origin)
Cell-> Piece ++: ValidMove(Position origin);
return List<Position>
return List<Position>
loop Remove all position out of board
    Board -> Position ++: OutOfBounds
    return List<Position>
end

'Can en passant
Board -> Cell ++: CanEnPassant()
Cell -> Piece ++: CanEnPassant()
return false
return false

'Check if can only attack diagonally "Not move"
Board -> Cell ++: CanOnlyAttackDiagonally() "Not move"
Cell -> Piece ++: CanOnlyAttackDiagonally()
return false
return false

'Check if can only move forward
Board -> Cell ++: CanOnlyMoveForward()
Cell -> Piece ++: CanOnlyMoveForward()
return false
return false

'If moves containes target

'Check for collisions
Board -> Board ++: Collision(Position origin, Position target, List<Position> moves)
Board -> Board ++: ConvertToIndex(Position position)
return (int)index of origin
Board -> Cell ++: HasCollision()
Cell -> Piece ++: CanCollide
return true
return true

Board -> Board ++: PositionsBetween(Position origin, Position target, List<Position>)
return List<Position> "All position between"
loop Check if all position are empty
    Board -> Board ++: ConvertToIndex(Position position)
    return (int)index
    Board -> Cell ++: IsEmpty()
    return true
end
return true
return true

'--------- Self check ---------'
Match -> Board ++: SelfChecks(Position origin, Position target)
Board -> Board ++: ConvertToIndex(Position position)
return (int)index of origin
Board -> Cell ++: Color
return white;

'Swap cell
Board -> Board ++: SwapCells(Position origin, Position target)
Board -> Board ++: ConvertToIndex(Position position)
return (int)index of origin
Board -> Board ++: ConvertToIndex(Position position)
return (int)index of target
Board -> Cell ++: new Cell(string)
return Cell
return

'--- Get assaillants ---'
Board -> Board ++: GetAssaillants(Colour color)

group GetEssential
'Get essential piece
Board -> Board ++: GetEssentialPiece(Colour colour)
loop until it get the essential piece
    Board -> Cell ++: HasEssential()
    return true
    Board -> Cell ++: Color
    return White
end
Board -> Board ++: ConvertToPosition(int index)
Board -> Position ++: New Position(int x, int y)
return Position
return Position "of the essential" 
end

'Is essential piece exits
Board -> Piece ++: OutOfBounds
return false

'Get attacking pieces/
Board -> Board ++: SameColour(Position origine, Colour colour)
Board -> Board ++: ConvertToIndex()
return index of piece
Board -> Cell ++: Colour
return Black
return false

loop For all ennemies and adding them into a list<Position>
    Board -> Board ++: ConvertToPosition(int index)
    return Position
end

loop For all ennemies and put them in a list
    Board -> Board ++: ValidMove(Position origin, Position target)[...]
    return true
end

loop Until it found an essential in the ennemy list
    group GetEssential
        'Get essential piece
        Board -> Board ++: GetEssentialPiece(Colour colour)[...]
        return Position "of the essential" 
    end
end

'///////JE COMPREND fuck all comment Ã§a marche 
'if (list.Contains(GetEssentialPiece(enemyColour)))
'{
 '   list.RemoveAll(enemy => _cells[ConvertToIndex(enemy)].HasEssential() && !SelfChecks(enemy, target));
'}

note right
    Dude je comprend fuck all HELPPPPP!!!!!!!!

end note
loop Remove all cell that are fitting condition
    'Board -> Board ++: ConvertToIndex()
    'return index of piece
    'Board -> Cell ++: HasEssential()
    'return false
end
return List<Position>
return List<Position> "Pieces attacking the current essential"

return false

'--------- Origin is essential ---------'
Match -> Board ++: HasEssential(Position cell)
Board -> Board ++: ConvertToIndex()
return index of the origin
Board -> Cell ++: HasEssential()
Cell -> Piece ++: IsEssetial()
return false
return false
return false

'--------- Valid move ---------'
return true

